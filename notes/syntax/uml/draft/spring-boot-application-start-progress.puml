@startuml
'hide footbox
skinparam backgroundColor #EEEBDC
skinparam handwritten true

skinparam Participant {
    BorderColor DeepSkyBlue
    BackgroundColor DodgerBlue
    FontSize 14
    FontColor #EEEBDC
    FontStyle bold
}

skinparam Actor {
    BorderColor DeepSkyBlue
    BackgroundColor aqua
    FontColor DeepSkyBlue
    FontSize 17
    FontStyle bold
    FontName Aapex
}

skinparam sequence {
    CircledCharacterFontColor blue
    ArrowColor DeepSkyBlue
    ArrowFontName Consolas

    LifeLineBorderColor blue
    LifeLineBackgroundColor #A9DCDF
}

actor User as U
participant "Application" as A << (C,blue) >>
participant "Spring Application" as SA << (C,blue) >>
participant "new Spring Application()" as NSA << (C,darkGreen) >>
participant "WebApplicationType" as WebType << (C,blue) >> order 1000
participant "SpringFactoriesLoader" as SpringFactoriesLoader << (C,blue) >> order 990
participant "AnnotationAwareOrderComparator" as AnnotationAwareOrderComparator << (C,blue) >> order 995


autoactivate on

U -> A: main(String[], args)

A -> SA: SpringApplication\n.run(Application.class, args)

SA -> NSA: **1** new SpringApplication(primarySources)
note over SA
这里的primarySources通常仅有前面的Application.class
end note

return an SpringApplication instance

SA -> NSA: **2** run(args)

NSA -> NSA: this(null, primarySources)

group 内部调用构造函数this(null, primarySources)
note over NSA #GoldenRod
public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
    this.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, "PrimarySources must not be null");
    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = deduceMainApplicationClass();
}
end note
note over NSA
执行this.resourceLoader = resourceLoader;

根据前面调用的结果，此时的赋值相当于this.resourceLoader存放了null;
end note
note over NSA
执行Assert.notNull(primarySources, "PrimarySources must not be null");

断言...不能为null
end note
note over NSA
执行this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));

this.primarySources存放了指向1个空间的LinkedHashSet的引用
end note
note over NSA
执行this.webApplicationType = WebApplicationType.deduceFromClasspath();
end note
note right of NSA
外部调用
end note
NSA -> WebType: WebApplicationType.deduceFromClasspath()
note over WebType
forName方法加载一些代表web应用类型的主要类，
看它们是否在类路径中，以此判断web类型
end note
return enum of WebApplicationType\nrepresenting current web application type

note over NSA
执行setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
end note
note right of NSA
内部调用
end note
NSA -> NSA: setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
group setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class))
note over NSA #GoldenRod
Collection<ApplicationContextInitializer.class> coll = getSpringFactoriesInstances(ApplicationContextInitializer.class);
setInitializers((Collection) coll);
end note
note over NSA
执行Collection<ApplicationContextInitializer.class> coll = getSpringFactoriesInstances(ApplicationContextInitializer.class);
end note
note right of NSA
内部调用
end note
NSA -> NSA: getSpringFactoriesInstances(ApplicationContextInitializer.class)
group getSpringFactoriesInstances(ApplicationContextInitializer.class)
NSA -> NSA: getSpringFactoriesInstances(type, new Class<?>[] {})
note over NSA  #GoldenRod
private <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {
    ClassLoader classLoader = getClassLoader();
    // Use names and ensure unique to protect against duplicates
    Set<String> names = new LinkedHashSet<>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    List<T> instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
    AnnotationAwareOrderComparator.sort(instances);
    return instances;
}
end note
note over NSA
执行ClassLoader classLoader = getClassLoader();
end note
note right of NSA
内部调用，获取类加载器，spring boot设计了类加载器可复用，方法如下，不再具体说明
end note
note right of NSA
public ClassLoader getClassLoader() {
    if (this.resourceLoader != null) {
        return this.resourceLoader.getClassLoader();
    }
    return ClassUtils.getDefaultClassLoader();
}
end note
note over NSA
执行Set<String> names = new LinkedHashSet<>(SpringFactoriesLoader.loadFactoryNames(type, classLoader))
end note
note right of NSA
先外部调用，加载并实例化给定类型的工厂
end note
NSA -> SpringFactoriesLoader: SpringFactoriesLoader.loadFactoryNames(type, classLoader)
group loadFactoryNames(type, classLoader)
note over SpringFactoriesLoader #GoldenRod
public static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {
    String factoryTypeName = factoryType.getName();
    return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
}
end note
note over SpringFactoriesLoader
执行String factoryTypeName = factoryType.getName();

获取这个工厂类的全类名
end note
note over SpringFactoriesLoader
执行return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
end note
note right of NSA
内部调用
end note
SpringFactoriesLoader -> SpringFactoriesLoader: return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
group return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());
note over SpringFactoriesLoader
首先内部调用loadSpringFactories(classLoader)，获取Map<String, List<String>>
end note
SpringFactoriesLoader -> SpringFactoriesLoader: loadSpringFactories(classLoader)
group loadSpringFactories(classLoader)
note over SpringFactoriesLoader #GoldenRod
private static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {
    MultiValueMap<String, String> result = cache.get(classLoader);
    if (result != null) {
        return result;
    }

    try {
        Enumeration<URL> urls = (classLoader != null ?
        classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
        ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
        result = new LinkedMultiValueMap<>();
        while (urls.hasMoreElements()) {
            URL url = urls.nextElement();
            UrlResource resource = new UrlResource(url);
            Properties properties = PropertiesLoaderUtils.loadProperties(resource);
            for (Map.Entry<?, ?> entry : properties.entrySet()) {
                String factoryTypeName = ((String) entry.getKey()).trim();
                for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {
                    result.add(factoryTypeName, factoryImplementationName.trim());
                }
            }
        }
        cache.put(classLoader, result);
        return result;
    }catch (IOException ex) {
        throw new IllegalArgumentException("Unable to load factories from location [" +
                FACTORIES_RESOURCE_LOCATION + "]", ex);
    }
}
end note
note over SpringFactoriesLoader
总的来说：
        spring framework使用形参classLoader的getResource()方法（或者这个形参为null时，使用类ClassLoader的
静态方法getSystemResource()）加载classpath下所有的第三方库和Java库中所有**META_INF/spring.factories**文件，
返回封装这些文件路径的URL类的Enumeration集合
        接下来遍历Enumeration集合，按properties文件格式解析、读取这些文件（所以要求spring.factories文件一定是
properties文件，即key=value1,value2,value3...valuen），将读取到的key作为key，读取到的value经过StringUtils
split之后得到的每个value组成键值对，放到spring framework以LinkedHashMap转化定义的数据结构LinkedMultiValueMap，
实现重点是：
LinkedMultiValueMap<k, v> implements MultiValueMap<k, v>
    MultiValueMap<k, v> extends Map<k, List<v>>
这个LinkedMultiValueMap<k, v>内部维护的是LinkedHashMap<k, LinkedList<v>>，也就是key相同的value
是以链表的形式存放的，结构不保证并发可用。
        上述遍历过程得到的MultiValueMap<String, String>被缓存，缓存这个对象的field是cache，它的定义是：
Map<ClassLoader, MultiValueMap<String, String>> cache = new ConcurrentReferenceHashMap<>();
类ConcurrentReferenceHashMap并发可用，但key和value都用了软引用或弱引用，可能被GC，因此不保证一次缓存，始终有效。
        此说明从重点代码段讲起，未遵从程序控制。要说明的是方法开始就是尝试从缓存拿数据，没有才执行上述过程。
        最终返回factory type name和该factory管理的类的全类名键值对集
end note
return Map<String, List<String>>\n-- <factoryTypeName, factoryManagedClassList>
end
note over SpringFactoriesLoader
拿到返回的factory type name和该factory管理的类的全类名键值对集之后，根据形参factoryTypeName get操作即可得到
注册到形参factoryTypeName工厂类的全类名。
end note
return List<String>\n-- full class name of current factory type managed class
end
return List<String>\n-- full class name of current factory type managed class
end
note over NSA
拿到List<String>，封装为set，剔除有可能的重复。
执行List<T> instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
end note
note right of NSA
内部调用，实例化该工厂管理的类
end note
NSA -> NSA: createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names)
group createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names)
note over NSA #GoldenRod
@SuppressWarnings("unchecked")
private <T> List<T> createSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, ClassLoader classLoader, Object[] args, Set<String> names) {
    List<T> instances = new ArrayList<>(names.size());
    for (String name : names) {
        try {
            Class<?> instanceClass = ClassUtils.forName(name, classLoader);
            Assert.isAssignable(type, instanceClass);
            Constructor<?> constructor = instanceClass.getDeclaredConstructor(parameterTypes);
            T instance = (T) BeanUtils.instantiateClass(constructor, args);
            instances.add(instance);
        }catch (Throwable ex) {
            throw new IllegalArgumentException("Cannot instantiate " + type + " : " + name, ex);
        }
    }
    return instances;
}
end note

note over NSA
        遍历形参names，加载每个name表示的类，再断言name加载到的类instanceClass，它的超类或超接口都要是形参type。
然后通过类获取类的构造方法（同时进行权限检查，具体这里不再讨论），最后构造它的示例。
        最终返回形参type在spring.factories中声明的实现或子类的实例列表。
end note
return List<T>\n-- instance list of every sub class of given type.
end
note over NSA
执行AnnotationAwareOrderComparator.sort(instances);
end note
note right of NSA
外部调用
end note
NSA -> AnnotationAwareOrderComparator: AnnotationAwareOrderComparator.sort(instances)
group AnnotationAwareOrderComparator.sort(instances)
note over AnnotationAwareOrderComparator
todo
end note
return
end
return List<T>\n-- sorted instance list of every sub class of given type.
end
note over NSA
执行setInitializers((Collection) coll);
end note
note right of NSA
内部调用，一个set操作
end note
end
note over NSA
执行setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class))
end note
note right of NSA
内部调用
end note
NSA -> NSA: setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class))
group setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class))
note over NSA
此过程和setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class))
一样，唯一不同的是工厂类型不同，过程不再赘述
end note
end
note over NSA
执行this.mainApplicationClass = deduceMainApplicationClass();
推断main方法，并赋值
end note
return
end
NSA --> SA: application starting...
SA --> A: application starting...
A --> U: print output about application starting... in console
@enduml